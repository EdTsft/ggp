"""Translation between Prefix GDL and Prolog"""
from pygdl.languages import prefixgdl, prolog


class PrologToPrefixGdl(object):
    """Translate Prolog to Prefix GDL"""
    def __init__(self, bijective=True):
        """Create a prolog to prefix GDL translator.

        If bijective is True, then the translation is reversable by
        PrefixGdlToProlog. In bijective mode, all given prolog variables must
        begin with an underscore, as if generated by
        PrefixGdlToProlog(bijective=True).

        If bijective is False, then the translation might not be reversable.

        Either way, unique gdl variables are guaranteed to remain unique when
        translated. This is not the case for PrefixGdlToProlog(bijective=False).
        """
        super().__init__()
        self.bijective = bijective

    def translate_parsed_prolog_term(self, parsed_prolog_term):
        """Translated a ParsedPrologTerm to a PrefixGdlTerm."""

        if isinstance(parsed_prolog_term, prolog.PrologConstant):
            return self.translate_constant(parsed_prolog_term)

        elif isinstance(parsed_prolog_term, prolog.PrologVariable):
            return self.translate_variable(parsed_prolog_term)

        elif isinstance(parsed_prolog_term, prolog.PrologCompoundTerm):
            return self.translate_compound_term(parsed_prolog_term)
        else:
            raise AssertionError('Unexpected prolog term type: {}'.format(
                type(parsed_prolog_term)))

    def translate_constant(self, constant):
        """Translate PrologConstant to PrefixGdlAtom."""
        if isinstance(constant, prolog.PrologAtom):
            return self.translate_atom(constant)
        else:
            return prefixgdl.PrefixGdlAtom(str(constant))

    def translate_atom(self, atom):
        """Translate PrologAtom to PrefixGdlAtom."""
        assert isinstance(atom, prolog.PrologAtom)
        # str(atom) may result in a quoted string
        # when the quotes should not appear in GDL
        return prefixgdl.PrefixGdlAtom(str(atom.name))

    def translate_variable(self, variable):
        """Translate PrologVariable to PrefixGdlVariable."""
        assert isinstance(variable, prolog.PrologVariable)
        name = str(variable.name)
        if self.bijective:
            if name[0] != '_':
                raise ValueError("In bijective mode, all variables must "
                                 "begin with underscore.")
            if name == '_':
                raise ValueError("Single underscore variable not allowed "
                                 "when translating in bijective mode.")
            return prefixgdl.PrefixGdlVariable(name[1:])
        else:
            return prefixgdl.PrefixGdlVariable(name[0].lower() + name[1:])

    def translate_compound_term(self, compound_term):
        """Translate PrologCompoundTerm to PrefixGdlCompoundTerm."""
        assert isinstance(compound_term.name, prolog.PrologAtom)
        name = compound_term.name.name
        args = compound_term.args
        if name == _prolog_rule_operator:
            name = _prefix_gdl_rule_operator

            # Prolog version of rule operator has arity 2 but GDL version is
            # variadic. Expand out a sequence of AND operators to create the
            # variadic call.
            assert len(args) == 2
            args = (args[0],) + self._expand_prolog_conjunction(args[1])

        return prefixgdl.PrefixGdlCompoundTerm(
            name=name,
            args=tuple(self.translate_parsed_prolog_term(arg) for arg in args))

    @staticmethod
    def _expand_prolog_conjunction(prolog_term):
        """Expand the conjuction represented by prolog_term

        Return a tuple of terms, where prolog_term represents a conjunction of
        these terms.
        """
        if ((isinstance(prolog_term, prolog.PrologCompoundTerm) and
             prolog_term.name.name == _prolog_and_operator)):
            assert prolog_term.arity == 2
            return (
                PrologToPrefixGdl._expand_prolog_conjunction(
                    prolog_term.args[0]) +
                PrologToPrefixGdl._expand_prolog_conjunction(
                    prolog_term.args[1]))
        else:
            return (prolog_term,)


class PrefixGdlToProlog(object):
    """Translates prefix GDL to Prolog."""

    def __init__(self, bijective=True):
        """Create prefix to prolog translator.

        If bijective is True, then the translation is reversable by
        PrologToPrefixGdl. All variable names will have an underscore prepended
        to ensure that they are valid prolog variables without the possiblility
        of a name conflict.

        If bijective is False, then translating with PrefixGdlToProlog followed
        by PrologToPrefixGdl might not produce the original text.

        WARNING: If bjective is False, unique prefix gdl variables are NOT
        guaranteed to remain unique when translated to prolog. Prefix GDL
        variable names will be translated to the closest valid prolog variable
        name and name conflicts are possible.  e.g., ?var and ?Var will both be
        translated to Var
        """
        super().__init__()
        self._prefix_gdl_parser = prefixgdl.PrefixGdlParser()
        self.bijective = bijective

    def translate(self, instring):
        """Translate a prefix gdl string to a list of PrologTerm."""
        return self.translate_statements(
            self._prefix_gdl_parser.parse(instring))

    def translate_statements(self, statements):
        """Translate a PrefixGdlStatements object to a list of PrologTerm."""
        self._check_type(statements, prefixgdl.PrefixGdlStatements)
        return [self.translate_term(term) for term in statements]

    def translate_term(self, term):
        """Translate a PrefixGdlTerm to a PrologTerm."""
        self._check_type(term, prefixgdl.PrefixGdlTerm)
        if isinstance(term, prefixgdl.PrefixGdlAtomicTerm):
            return self.translate_atomic_term(term)
        elif isinstance(term, prefixgdl.PrefixGdlCompoundTerm):
            return self.translate_compound_term(term)
        else:
            raise TypeError("Unexpected term type {}".format(
                type(term).__name__))

    def translate_atomic_term(self, atomic_term):
        """Translate a PrefixGdlAtomicTerm to a PrologNonCompoundTerm."""
        self._check_type(atomic_term, prefixgdl.PrefixGdlAtomicTerm)
        if isinstance(atomic_term, prefixgdl.PrefixGdlAtom):
            return self.translate_atom(atomic_term)
        elif isinstance(atomic_term, prefixgdl.PrefixGdlVariable):
            return self.translate_variable(atomic_term)
        else:
            raise TypeError("Unexpected atomic term type {}".format(
                type(atomic_term).__name__))

    def translate_atom(self, atom):
        """Translate a PrefixGdlAtom to a PrologAtom."""
        self._check_type(atom, prefixgdl.PrefixGdlAtom)
        return prolog.PrologAtom(atom.name)

    def translate_variable(self, variable):
        """Translate a PrefixGdlVariable to a PrologVariable.

        If self.bijective, translation will avoid name conflicts.
        Otherwise, translation will minimize modifications to the name.
        """
        self._check_type(variable, prefixgdl.PrefixGdlVariable)
        name = variable.name
        if self.bijective:
            name = '_' + name
        else:
            if name[0].isalpha():
                name = name.capitalize()
            elif name[0] != '_':
                name = '_' + name
        return prolog.PrologVariable(name)

    def translate_compound_term(self, compound_term):
        """Translate a PrefixGdlCompoundTerm to a PrologCompoundTerm."""
        self._check_type(compound_term, prefixgdl.PrefixGdlCompoundTerm)
        name = compound_term.name
        args = [self.translate_term(arg) for arg in compound_term.args]

        if name == _prefix_gdl_rule_operator:
            name = _prolog_rule_operator
            # The GDL version of this operator is variadic,
            # but the Prolog version has arity 2.
            args = (args[0], prolog.PrologTerm.and_(*args[1:]))

        return prolog.PrologTerm.make_compound_term(
            name=name, args=args)

    @staticmethod
    def _check_type(arg, required_type):
        if not isinstance(arg, required_type):
            raise TypeError("Argument of type {} required, not {}".format(
                required_type.__name__, type(arg).__name__))


_prolog_and_operator = ','
_prolog_rule_operator = ':-'
_prefix_gdl_rule_operator = '<='
_prefix_gdl_variable_token = '?'
